# coding=utf-8
import datetime
import random
from DjangoCaptcha import Captcha
from django.contrib import auth
from django.core.paginator import Paginator, EmptyPage, InvalidPage
from searcher.models import Bid, UserFilter, DimensionChoice

__author__ = 'py'


def user_auth(request, username, password, code):
    user = auth.authenticate(username=username, password=password)
    _code = code
    ca = Captcha(request)
    if user is None:
        return 2
    elif not user.is_active:
        return 3
    elif not ca.check(_code):
        return 4
    else:
        auth.login(request, user)
        return 1


def combination_bid(amount, ctype):
    # date1 = datetime.datetime.now()

    if None == amount:
        a = Bid.objects.filter(comb_type=ctype)
    else:
        a = Bid.objects.filter(amount__lte=amount, comb_type=ctype)
    if len(a) >= 2:
        aa = random.sample(a, 2)
        cid = []
        for t in aa:
            cid.append(str(t.id))
        c = {'ids': '&'.join(cid)}
        #print(c)
        c.update({'term': str(aa[0].term) + '/' + str(aa[1].term)})
        c.update({'income_rate': (aa[0].income_rate + aa[1].income_rate) / 2})
        if ctype == 1:
            c.update({'name': '益起贷 上选 保守型'})
        elif ctype == 2:
            c.update({'name': '益起贷 优选 稳健型'})
        elif ctype == 3:
            c.update({'name': '益起贷 精选 激进型'})
        c.update({'amount': (aa[0].amount + aa[1].amount)})
        c.update({'thousandincome': (aa[0].thousandincome + aa[1].thousandincome)})
    else:
        c = None
    # date2 = datetime.datetime.now()
    # print(u'组合耗时' + str(ctype) + str((date2 - date1).seconds) + u'秒')
    return c


def fil_yield(results, cal_type, value1, value2):
    if cal_type == 1:
        return results.filter(income_rate__lte=value1)
    elif cal_type == 2:
        return results.filter(income_rate=value1)
    elif cal_type == 3:
        return results.filter(income_rate__gte=value1)
    elif cal_type == 4:
        return results.filter(income_rate__gte=value1, income_rate__lte=value2)
    elif cal_type == 0:
        return results


def fil_time(results, cal_type, value1, value2):
    if cal_type == 1:
        return results.filter(term__lte=value1)
    elif cal_type == 2:
        return results.filter(term=value1)
    elif cal_type == 3:
        return results.filter(term__gte=value1)
    elif cal_type == 4:
        return results.filter(term__gte=value1, term__lte=value2)
    elif cal_type == 0:
        return results


def fil_lz(results, cal_type, value1, value2):
    if cal_type == 0:
        return results
    elif cal_type == 2:
        if value1 == 1:
            return results.filter(transfer_claim='Y')
        else:
            return results.filter(transfer_claim='N')


def fil_capital(results, cal_type, value1, value2):
    if cal_type == 0:
        return results
    elif cal_type == 1:
        return results.filter(platform__capital__lte=value1)
    elif cal_type == 3:
        return results.filter(platform__capital__gte=value1)
    elif cal_type == 4:
        return results.filter(platform__capital__gte=value1, platform__capital__lte=value2)


def fil_online(results, cal_type, value1, value2):
    if cal_type == 0:
        return results
    elif cal_type == 1:
        return results.filter(platform__online_time__gte=datetime_offset_by_month(datetime.date.today(), -value1))
    elif cal_type == 3:
        return results.filter(platform__online_time__lte=datetime_offset_by_month(datetime.date.today(), -value1))
    elif cal_type == 4:
        return results.filter(platform__online_time__lte=datetime_offset_by_month(datetime.date.today(), -value1),
                              platform__online_time__gte=datetime_offset_by_month(datetime.date.today(), -value2))


def fil_type(results, cal_type, choice_name):
    if cal_type == 0:
        return results
    elif cal_type == 2:
        return results.filter(type=choice_name)


def datetime_offset_by_month(datetime1, n=1):
    # create a shortcut object for one day
    one_day = datetime.timedelta(days=1)

    # first use div and mod to determine year cycle
    q, r = divmod(datetime1.month + n, 12)

    # create a datetime2
    # to be the last day of the target month
    datetime2 = datetime.datetime(
        datetime1.year + q, r + 1, 1) - one_day

    # if input date is the last day of this month
    # then the output date should also be the last
    # day of the target month, although the day
    # may be different.
    # for example:
    # datetime1 = 8.31
    # datetime2 = 9.30
    if datetime1.month != (datetime1 + one_day).month:
        return datetime2

    # if datetime1 day is bigger than last day of
    # target month, then, use datetime2
    # for example:
    # datetime1 = 10.31
    # datetime2 = 11.30
    if datetime1.day >= datetime2.day:
        return datetime2

    # then, here, we just replace datetime2's day
    # with the same of datetime1, that's ok.
    return datetime2.replace(day=datetime1.day)


def get_user_filter(user):
    f_l = []
    f_list = UserFilter.objects.filter(user=user)
    if len(f_list) > 0:
        for f in f_list:
            k = str(f.choices)
            a = map(int, k.split(','))
            filters = DimensionChoice.objects.filter(id__in=a)
            f_l.append({'id': f.id, 'choices': k, 'filters': filters})
    return f_l


def data_filter(data, filters):  # queryset
    results = data
    for f in filters:
        if f.dimension.id == 1:
            results = fil_yield(results, f.cal_type, f.choice_value1, f.choice_value2)
        elif f.dimension.id == 2:
            results = fil_time(results, f.cal_type, f.choice_value1, f.choice_value2)
        elif f.dimension.id == 3:
            results = fil_lz(results, f.cal_type, f.choice_value1, f.choice_value2)
        elif f.dimension.id == 4:
            results = fil_capital(results, f.cal_type, f.choice_value1, f.choice_value2)
        elif f.dimension.id == 5:
            results = fil_online(results, f.cal_type, f.choice_value1, f.choice_value2)
        elif f.dimension.id == 6:
            results = fil_type(results, f.cal_type, f.choice_name)
    return results


def index_loading(amount, params, page):
    c_bs = combination_bid(amount, 1)
    c_wj = combination_bid(amount, 2)
    c_jj = combination_bid(amount, 3)
    c_result = [c_bs, c_wj, c_jj]
    dimensions = DimensionChoice.objects.all()
    if None == amount:
        results = Bid.objects.all()
    else:
        results = Bid.objects.filter(amount__gte=amount).order_by("id")
    if params is not None:
        a = params.split(',')
        filters = DimensionChoice.objects.filter(id__in=a)
        results = data_filter(results, filters)
    ppp = Paginator(results, 5)
    last_page = ppp.page_range[len(ppp.page_range) - 1]
    try:
        results = ppp.page(page)
    except (EmptyPage, InvalidPage):
        results = ppp.page(ppp.num_pages)
    page_set = get_pageset(last_page, results.number)
    index_parts = {'dimensions': dimensions, 'results': results, 'c_result': c_result, 'last_page': last_page,
                   'page_set': page_set}
    return index_parts


def get_pageset(last_page, pagenum):
    page_set = []
    if pagenum <= 3:
        start = 0
        end = 6
    elif pagenum > last_page - 3:
        start = last_page - 4
        end = last_page + 1
    else:
        start = pagenum - 2
        end = pagenum + 3
    for i in range(start, end, 1):
        if i <= 0:
            pass
        elif i > last_page:
            break
        else:
            page_set.append(i)
    return page_set